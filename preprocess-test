<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpalForge Preprocessing Diagnostic</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 30px 20px;
            background: #1a1a2e;
            color: #f0f0f0;
        }
        h1 { color: #B8860B; text-align: center; }
        .card {
            background: #16213e;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid #0f3460;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #0f3460;
        }
        th { color: #B8860B; }
        .match { background: #1e4d3d; color: #4ade80; }
        .no-match { background: #4d1e1e; color: #f87171; }
        .close { background: #4d3d1e; color: #fbbf24; }
        button {
            background: linear-gradient(90deg, #B8860B, #C0C0C0);
            color: #000040;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { transform: translateY(-2px); }
        input[type="file"] { margin: 15px 0; }
        #preview { max-width: 200px; border-radius: 8px; margin: 15px 0; }
        .info { color: #888; font-size: 14px; }
        pre {
            background: #0f0f1a;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 12px;
        }
        #targetScore {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #B8860B;
            background: #0f0f1a;
            color: #f0f0f0;
            width: 100px;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <h1>üî¨ OpalForge Preprocessing Diagnostic</h1>
    
    <div class="card">
        <h3 style="margin-top:0; color:#B8860B;">Step 1: Enter Expected Result from Teachable Machine</h3>
        <p class="info">Upload an image to Teachable Machine first, note the "Replica" percentage, then enter it here:</p>
        <label>
            Expected Replica %: 
            <input type="number" id="targetScore" value="94" min="0" max="100">
        </label>
    </div>

    <div class="card">
        <h3 style="margin-top:0; color:#B8860B;">Step 2: Upload the Same Image</h3>
        <input type="file" id="imageInput" accept="image/*">
        <br>
        <img id="preview" style="display:none;">
    </div>

    <div class="card">
        <h3 style="margin-top:0; color:#B8860B;">Step 3: Results</h3>
        <div id="results">
            <p class="info">Upload an image to test different preprocessing methods...</p>
        </div>
    </div>

    <div class="card">
        <h3 style="margin-top:0; color:#B8860B;">Recommendation</h3>
        <div id="recommendation">
            <p class="info">Results will appear here after testing...</p>
        </div>
    </div>

    <script>
        let model = null;

        // Different preprocessing methods to test
        const preprocessMethods = [
            {
                name: "0 to 1 (div 255)",
                description: "normalized = pixels / 255",
                fn: (tensor) => tensor.toFloat().div(255.0)
            },
            {
                name: "-1 to 1 (Teachable Machine)",
                description: "normalized = (pixels / 127.5) - 1",
                fn: (tensor) => tensor.toFloat().div(127.5).sub(1.0)
            },
            {
                name: "0 to 1 (div 255) - ImageNet mean",
                description: "normalized = (pixels / 255) - [0.485, 0.456, 0.406]",
                fn: (tensor) => tensor.toFloat().div(255.0).sub(tf.tensor([0.485, 0.456, 0.406]))
            },
            {
                name: "Raw pixels (no normalization)",
                description: "normalized = pixels (0-255)",
                fn: (tensor) => tensor.toFloat()
            },
            {
                name: "-1 to 1 (alternative)",
                description: "normalized = (pixels - 127.5) / 127.5",
                fn: (tensor) => tensor.toFloat().sub(127.5).div(127.5)
            }
        ];

        async function loadModel() {
            if (model) return model;
            document.getElementById('results').innerHTML = '<p>Loading model...</p>';
            try {
                model = await tf.loadLayersModel('./model/model.json');
                console.log('Model loaded');
                return model;
            } catch (err) {
                document.getElementById('results').innerHTML = `<p style="color:red;">Failed to load model: ${err.message}</p>`;
                throw err;
            }
        }

        async function testPreprocessing(imgElement) {
            const m = await loadModel();
            const targetReplica = parseFloat(document.getElementById('targetScore').value) / 100;
            const targetAuthentic = 1 - targetReplica;
            
            let resultsHTML = `
                <p><strong>Target from Teachable Machine:</strong> Authentic: ${(targetAuthentic * 100).toFixed(1)}%, Replica: ${(targetReplica * 100).toFixed(1)}%</p>
                <table>
                    <tr>
                        <th>Preprocessing Method</th>
                        <th>Index 0 (Auth)</th>
                        <th>Index 1 (Rep)</th>
                        <th>Replica %</th>
                        <th>Match?</th>
                    </tr>
            `;

            let bestMatch = null;
            let bestDiff = Infinity;

            for (const method of preprocessMethods) {
                try {
                    const result = tf.tidy(() => {
                        let imgTensor = tf.browser.fromPixels(imgElement);
                        
                        if (imgTensor.shape[2] === 4) {
                            imgTensor = imgTensor.slice([0, 0, 0], [-1, -1, 3]);
                        }
                        
                        const resized = tf.image.resizeBilinear(imgTensor, [224, 224]);
                        const normalized = method.fn(resized);
                        const batched = normalized.expandDims(0);
                        const prediction = m.predict(batched);
                        return prediction.dataSync();
                    });

                    const auth = result[0];
                    const rep = result[1];
                    const diff = Math.abs(rep - targetReplica);
                    
                    let matchClass = 'no-match';
                    let matchText = '‚ùå No';
                    
                    if (diff < 0.02) {
                        matchClass = 'match';
                        matchText = '‚úÖ YES!';
                    } else if (diff < 0.10) {
                        matchClass = 'close';
                        matchText = '‚ö†Ô∏è Close';
                    }

                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestMatch = method;
                    }

                    resultsHTML += `
                        <tr class="${matchClass}">
                            <td><strong>${method.name}</strong><br><span class="info">${method.description}</span></td>
                            <td>${auth.toFixed(4)}</td>
                            <td>${rep.toFixed(4)}</td>
                            <td>${(rep * 100).toFixed(1)}%</td>
                            <td>${matchText}</td>
                        </tr>
                    `;
                } catch (err) {
                    resultsHTML += `
                        <tr class="no-match">
                            <td>${method.name}</td>
                            <td colspan="4">Error: ${err.message}</td>
                        </tr>
                    `;
                }
            }

            resultsHTML += '</table>';
            document.getElementById('results').innerHTML = resultsHTML;

            // Show recommendation
            let recHTML = '';
            if (bestDiff < 0.02) {
                recHTML = `
                    <p style="color: #4ade80; font-size: 18px;">‚úÖ <strong>FOUND IT!</strong></p>
                    <p>The correct preprocessing method is: <strong>${bestMatch.name}</strong></p>
                    <p>Code to use:</p>
                    <pre>const normalized = ${bestMatch.description.split('=')[1].trim()};</pre>
                `;
            } else if (bestDiff < 0.10) {
                recHTML = `
                    <p style="color: #fbbf24; font-size: 18px;">‚ö†Ô∏è <strong>Close Match Found</strong></p>
                    <p>Best match: <strong>${bestMatch.name}</strong> (off by ${(bestDiff * 100).toFixed(1)}%)</p>
                    <p>This might work, but there could be other preprocessing differences.</p>
                `;
            } else {
                recHTML = `
                    <p style="color: #f87171; font-size: 18px;">‚ùå <strong>No Match Found</strong></p>
                    <p>None of the standard preprocessing methods match Teachable Machine's output.</p>
                    <p>Possible issues:</p>
                    <ul>
                        <li>Model files might be corrupted or different</li>
                        <li>Image resizing/cropping might be different</li>
                        <li>Browser caching old model files</li>
                    </ul>
                    <p>Try: Clear browser cache and reload, or re-export model from Teachable Machine.</p>
                `;
            }
            document.getElementById('recommendation').innerHTML = recHTML;
        }

        document.getElementById('imageInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const preview = document.getElementById('preview');
            const reader = new FileReader();

            reader.onload = (ev) => {
                preview.src = ev.target.result;
                preview.style.display = 'block';

                const img = new Image();
                img.onload = () => testPreprocessing(img);
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        });

        // Preload model
        loadModel();
    </script>
</body>
</html>
